import Block from './block';
import Validation from './validation';
import BlockInfo from './blockInfo';
import Transaction from './transaction';
import TransactionType from './transactionType';

/**
 * Blockchain class
 */

export default class Blockchain {
  blocks: Block[] = [];
  nextIndex: number = 0;
  static readonly difficulty_factor: number = 5; // Dificuldade padr√£o para o mock (pode ser ajustada conforme necess√°rio)
  static readonly MAX_DIFFICULTY: number = 62; // Dificuldade m√°xima permitida

  constructor() {
    
    this.blocks = [new Block({
        index: this.nextIndex,
        // Usamos hashPrevious aqui, pois o construtor do Block o espera (mesmo que a imagem mostre 'previousHash')
        hashPrevious: "0".repeat(64), 
        
        transactions: [new Transaction({
            type: TransactionType.FEE,
            data: new Date().toString()
        } as Transaction)]
    } as Block)]; 
    this.nextIndex++;
  }

  getLastBlock(): Block {
    return this.blocks[this.blocks.length - 1];  // Acessa o √∫ltimo bloco da blockchain
  }

  getDifficulty(): number {
        return Math.ceil(this.blocks.length / Blockchain.difficulty_factor);
    }


  getBlock(hash: string): Block | undefined {
    // Presume que 'this.blocks' √© o seu array de blocos.
    // O m√©todo 'find' percorre o array e retorna o primeiro bloco (b) onde b.hash √© igual ao hash procurado.
    return this.blocks.find(b => b.hash === hash);
}
 addBlock(block: Block): Validation {
  const lastBlock = this.getLastBlock();  // Obt√©m o √∫ltimo bloco

  // Chama o m√©todo isvalid() e recebe a inst√¢ncia de Validation
  const validation = block.isValid(lastBlock.hash, lastBlock.index,this.getDifficulty());

  if (!validation.success) {
    console.log(validation.message);  // Exibe a mensagem de erro no console
    return validation;  // Retorna o objeto Validation com sucesso: false
  }

  this.blocks.push(block);  // Adiciona o bloco √† blockchain
  this.nextIndex++;
  return new Validation(true);  // Retorna uma inst√¢ncia de Validation com sucesso: true
}


   isvalid(): Validation {  // percorre todos os blocos da nossa blockchain
    for (let i = this.blocks.length - 1; i > 0; i--) {  // come√ßa do final e vai diminuindo um
      const currentBlock = this.blocks[i];  // bloco na posi√ß√£o i
      const previousBlock = this.blocks[i - 1];  // bloco anterior

      // Passa corretamente os par√¢metros para o m√©todo isvalid
      const validation = currentBlock.isValid(previousBlock.hash, previousBlock.index,this.getDifficulty());  // Recebe uma inst√¢ncia de Validation

      if (!validation.success) {
        // Se qualquer bloco for inv√°lido, retorna uma nova inst√¢ncia de Validation com false e a mensagem de erro
        return new Validation(false, `Invalid block #${currentBlock.index}: ${validation.message}`);
      }
    }
    return new Validation();  // Se todos os blocos forem v√°lidos, retorna sucesso (true)
  }


    getFeerPerTx() : number {
      return 0.01;
 } // Exemplo fixo, pode ser ajustado conforme necess√°rio


  getNextBlock(): BlockInfo {
    const transactions = [new Transaction({
        data: new Date().toString()
    } as Transaction)];
    
  const difficulty = this.getDifficulty();
  const PreviousHash = this.getLastBlock().hash;
  const index = this.blocks.length;
  const feeperTx = this.getFeerPerTx();
  const maxdifficulty = Blockchain.MAX_DIFFICULTY;
  return{
    transactions,
    difficulty,
    PreviousHash,
    index,
    feeperTx,
    maxdifficulty
  } as BlockInfo
} // Retorna informa√ß√µes do pr√≥ximo bloco a ser minerado

}


// ============================================================================
// RESUMO DA CLASSE BLOCKCHAIN
// ============================================================================
//
// Esta classe implementa uma blockchain completa com:
//
// ‚úÖ PROPRIEDADES:
// - blocks: Array contendo todos os blocos
// - nextIndex: Contador para o pr√≥ximo √≠ndice
//
// ‚úÖ M√âTODOS PRINCIPAIS:
// - constructor(): Inicializa com bloco g√™nesis
// - addBlock(): Adiciona blocos com valida√ß√£o rigorosa
// - isvalid(): Valida integridade de toda a cadeia
//
// ‚úÖ M√âTODOS AUXILIARES:
// - getLastBlock(): Retorna √∫ltimo bloco
// - getBlock(): Busca bloco por hash
//
// ‚úÖ CARACTER√çSTICAS DE SEGURAN√áA:
// - Valida√ß√£o antes de adicionar blocos
// - Encadeamento criptogr√°fico (hashPrevious)
// - Verifica√ß√£o de integridade de toda cadeia
// - Detec√ß√£o de adultera√ß√£o
//
// ‚úÖ IMUTABILIDADE:
// A estrutura garante que:
// 1. Blocos s√£o adicionados apenas no final
// 2. Cada bloco est√° criptograficamente ligado ao anterior
// 3. Alterar um bloco antigo quebra toda a cadeia
// 4. Fraudes s√£o facilmente detect√°veis
//
// ‚ö†Ô∏è LIMITA√á√ïES ATUAIS:
// - Armazenamento em mem√≥ria (perde dados ao reiniciar)
// - Sem persist√™ncia em banco de dados
// - Sem proof-of-work (minera√ß√£o) //esta sendo adicionado
// - Sem rede peer-to-peer (descentraliza√ß√£o)
// - Sem sistema de transa√ß√µes
// - Busca por hash √© O(n) (poderia ser O(1) com HashMap)
//
// ‚ö†Ô∏è MELHORIAS POSS√çVEIS:
// - Adicionar persist√™ncia (MongoDB, PostgreSQL, LevelDB)
// - Implementar proof-of-work para minera√ß√£o
// - Adicionar difficulty adjustment
// - Implementar Merkle Tree para transa√ß√µes
// - Adicionar sistema de wallets e transa√ß√µes
// - Implementar API RESTful completa
// - Adicionar sincroniza√ß√£o entre n√≥s (P2P)
// - Implementar fork resolution
// - Adicionar smart contracts (como Ethereum)
// - Otimizar busca com √≠ndices (HashMap)
// - Adicionar snapshot/checkpoints
// - Implementar pruning (limpeza de dados antigos)
//
// üí° USO T√çPICO:
// const blockchain = new Blockchain();  // Cria com bloco g√™nesis
// const bloco = new Block(1, blockchain.getLastBlock().hash, "dados");
// const resultado = blockchain.addBlock(bloco);
// if (resultado.success) {
//   console.log("Bloco adicionado!");
// }
//
// 
